/*
 * (C) Copyright 2012
 *     wangflord@allwinnertech.com
 *
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program;
 *
 */
#ifndef  __boot0_v2_h
#define  __boot0_v2_h


#define STAMP_VALUE                     0x5F0A6C39
#define BOOT0_MAGIC                     "eGON.BT0"

typedef struct
{
	unsigned int		ChannelCnt;
	unsigned int        ChipCnt;                            //the count of the total nand flash chips are currently connecting on the CE pin
    unsigned int       ChipConnectInfo;                    //chip connect information, bit == 1 means there is a chip connecting on the CE pin
	unsigned int		RbCnt;
	unsigned int		RbConnectInfo;						//the connect  information of the all rb  chips are connected
    unsigned int        RbConnectMode;						//the rb connect  mode
	unsigned int        BankCntPerChip;                     //the count of the banks in one nand chip, multiple banks can support Inter-Leave
    unsigned int        DieCntPerChip;                      //the count of the dies in one nand chip, block management is based on Die
    unsigned int        PlaneCntPerDie;                     //the count of planes in one die, multiple planes can support multi-plane operation
    unsigned int        SectorCntPerPage;                   //the count of sectors in one single physic page, one sector is 0.5k
    unsigned int       PageCntPerPhyBlk;                   //the count of physic pages in one physic block
    unsigned int       BlkCntPerDie;                       //the count of the physic blocks in one die, include valid block and invalid block
    unsigned int       OperationOpt;                       //the mask of the operation types which current nand flash can support support
    unsigned int        FrequencePar;                       //the parameter of the hardware access clock, based on 'MHz'
    unsigned int        EccMode;                            //the Ecc Mode for the nand flash chip, 0: bch-16, 1:bch-28, 2:bch_32
    unsigned char       NandChipId[8];                      //the nand chip id of current connecting nand chip
    unsigned int       ValidBlkRatio;                      //the ratio of the valid physical blocks, based on 1024
	unsigned int 		good_block_ratio;					//good block ratio get from hwscan
	unsigned int		ReadRetryType;						//the read retry type
	unsigned int       DDRType;
	unsigned int		Reserved[32];
}boot_nand_para_t0;

typedef struct _normal_gpio_cfg
{
    unsigned char      port;                       //绔彛鍙?
    unsigned char      port_num;                   //绔彛鍐呯紪鍙?
    char      mul_sel;                    //鍔熻兘缂栧彿
    char      pull;                       //鐢甸樆鐘舵€?
    char      drv_level;                  //椹卞姩椹卞姩鑳藉姏
    char      data;                       //杈撳嚭鐢靛钩
    unsigned char      reserved[2];                //淇濈暀浣嶏紝淇濊瘉瀵归綈
}normal_gpio_cfg;

/******************************************************************************/
/*                              file head of Boot0                            */
/******************************************************************************/
typedef struct _boot0_private_head_t
{
	unsigned int            prvt_head_size;
	char                    prvt_head_vsn[4];       // the version of boot0_private_head_t
	unsigned int            dram_para[32];          // DRAM patameters for initialising dram. Original values is arbitrary,
	int						uart_port;              // UART鎺у埗鍣ㄧ紪鍙?
	normal_gpio_cfg         uart_ctrl[2];           // UART鎺у埗鍣?璋冭瘯鎵撳嵃鍙?鏁版嵁淇℃伅
	int                     enable_jtag;            // 1 : enable,  0 : disable
    normal_gpio_cfg	        jtag_gpio[5];           // 淇濆瓨JTAG鐨勫叏閮℅PIO淇℃伅
    normal_gpio_cfg         storage_gpio[32];       // 瀛樺偍璁惧 GPIO淇℃伅
    char                    storage_data[512 - sizeof(normal_gpio_cfg) * 32];      // 鐢ㄦ埛淇濈暀鏁版嵁淇℃伅
    //boot_nand_connect_info_t    nand_connect_info;
}boot0_private_head_t;


typedef struct standard_Boot_file_head
{
	unsigned int  jump_instruction;   // one intruction jumping to real code
	unsigned char   magic[8];           // ="eGON.BT0" or "eGON.BT1",  not C-style string.
	unsigned int  check_sum;          // generated by PC
	unsigned int  length;             // generated by PC
	unsigned int  pub_head_size;      // the size of boot_file_head_t
	unsigned char   pub_head_vsn[4];    // the version of boot_file_head_t
	unsigned char   file_head_vsn[4];   // the version of boot0_file_head_t or boot1_file_head_t
	unsigned char   Boot_vsn[4];        // Boot version
	unsigned char   eGON_vsn[4];        // eGON version
	unsigned char   platform[8];        // platform information
}standard_boot_file_head_t;


typedef struct _boot0_file_head_t
{
	standard_boot_file_head_t   boot_head;
	boot0_private_head_t  		prvt_head;
}boot0_file_head_t;






#endif     //  ifndef __boot0_h

/* end of boot0.h */

typedef struct _boot_core_para_t
{
    unsigned int  user_set_clock;
    unsigned int  user_set_core_vol;
    unsigned int  vol_threshold;
}boot_core_para_t;


#ifndef  __uboot_h
#define  __uboot_h

/******************************************************************************/
/*                              file head of Boot2.0-uboot                          */
/******************************************************************************/
typedef struct _uboot_private_head_t
{
	unsigned int                dram_para[32];
	int							run_clock;				// Mhz
	int							run_core_vol;			// mV
	int							uart_port;              // UART鎺у埗鍣ㄧ紪鍙?
	normal_gpio_cfg             uart_gpio[2];           // UART鎺у埗鍣?璋冭瘯鎵撳嵃鍙?GPIO淇℃伅
	int							twi_port;               // TWI鎺у埗鍣ㄧ紪鍙?
	normal_gpio_cfg             twi_gpio[2];            // TWI鎺у埗鍣℅PIO淇℃伅锛岀敤浜庢帶鍒禩WI
	int		                    work_mode;              // 宸ヤ綔妯″紡
    int                         storage_type;           // 瀛樺偍浠嬭川绫诲瀷  0锛歯and   1锛歴dcard    2: spinor
    normal_gpio_cfg             nand_gpio[32];          // nand GPIO淇℃伅
    char						nand_spare_data[256];	// nand 棰濆淇℃伅
    normal_gpio_cfg             sdcard_gpio[32];		// sdcard GPIO淇℃伅
    char             			sdcard_spare_data[256];	// sdcard 棰濆淇℃伅
    int                         secureos_exist;
    unsigned int                uboot_start_sector_in_mmc;
    int							reserved[4];			// 淇濈暀鏁版嵁浣? 256bytes align
}uboot_private_head_t;

typedef struct _uBoot_file_head
{
	unsigned int  jump_instruction;   // one intruction jumping to real code
	unsigned char magic[8];  // ="u-boot"
	unsigned int  check_sum;          // generated by PC
	unsigned int  align_size;		  // align size in byte
	unsigned int  length;             // the size of all file
	unsigned int  uboot_length;       // the size of uboot
	unsigned char version[8];         // uboot version
	unsigned char platform[8];        // platform information
	int           reserved[1];        //stamp space, 16bytes align
}uboot_file_head;


typedef struct _uboot_file_head_t
{
	uboot_file_head      boot_head;
	uboot_private_head_t  prvt_head;
}uboot_file_head_t;

#endif     //  ifndef __uboot_h

/* end of uboot.h */

typedef struct _boot_dram_para_t
{
    unsigned int           dram_baseaddr;
    unsigned int           dram_clk;
    unsigned int           dram_type;
    unsigned int           dram_rank_num;
    unsigned int           dram_chip_density;
    unsigned int           dram_io_width;
    unsigned int		    dram_bus_width;
    unsigned int           dram_cas;
    unsigned int           dram_zq;
    unsigned int           dram_odt_en;
    unsigned int 			dram_size;
    unsigned int           dram_tpr0;
    unsigned int           dram_tpr1;
    unsigned int           dram_tpr2;
    unsigned int           dram_tpr3;
    unsigned int           dram_tpr4;
    unsigned int           dram_tpr5;
    unsigned int 			dram_emr1;
    unsigned int           dram_emr2;
    unsigned int           dram_emr3;
}boot_dram_para_t;

typedef struct _boot1_private_head_t
{
	unsigned int              prvt_head_size;
	unsigned char               prvt_head_vsn[4];                // the version of Boot1_private_hea
	int						uart_port;              // UART鎺у埗鍣ㄧ紪鍙?
	normal_gpio_cfg             uart_ctrl[2];           // UART鎺у埗鍣?璋冭瘯鎵撳嵃鍙?GPIO淇℃伅
	boot_dram_para_t      		dram_para;              // dram init para
	char                        script_buf[32 * 1024];  // 鑴氭湰鍙傛暟
	boot_core_para_t            core_para;              // 鍏抽敭鍙傛暟
	int						twi_port;               // TWI鎺у埗鍣ㄧ紪鍙?
	normal_gpio_cfg             twi_ctrl[2];            // TWI鎺у埗鍣℅PIO淇℃伅锛岀敤浜庢帶鍒禩WI
	int						debug_enable;           // debug浣胯兘鍙傛暟
    int                       hold_key_min;           // hold key鏈€灏忓€?
    int                       hold_key_max;           // hold key鏈€澶у€?
    unsigned int                       work_mode;              // 妯″紡锛屽尯鍒嗛噺浜ц繕鏄崌绾?
    unsigned int                       storage_type;           // 瀛樺偍浠嬭川绫诲瀷  0锛歯and   1锛歴dcard    2: spinor
    normal_gpio_cfg             storage_gpio[32];       // 瀛樺偍璁惧 GPIO淇℃伅
    char                        storage_data[512 - sizeof(normal_gpio_cfg) * 32];      // 鐢ㄦ埛淇濈暀鏁版嵁淇℃伅
    //boot_nand_connect_info_t    nand_connect_info;    // nand 鍙傛暟
}boot1_private_head_t;

typedef struct _Boot1_file_head
{
	unsigned int  jump_instruction;   // one intruction jumping to real code
	unsigned char   magic[8];           // ="eGON.BT0" or "eGON.BT1",  not C-style string.
	unsigned int  check_sum;          // generated by PC
	unsigned int  length;             // generated by PC
	unsigned int  boot1_length;       // the size of boot_file_head_t
	unsigned int  align_size;         // the align size of boot1
	unsigned char   file_head_vsn[4];   // the version of boot0_file_head_t or boot1_file_head_t
	unsigned char   Boot_vsn[4];        // Boot version
	unsigned char   eGON_vsn[4];        // eGON version
	unsigned char   platform[8];        // platform information
}boot1_file_head;

typedef struct _boot1_file_head_t
{
	boot1_file_head      boot_head;
	boot1_private_head_t  prvt_head;
}boot1_file_head_t;


/* end of boot1.h */

typedef struct sbrom_toc1_head_info
{
	char name[16]	;	//user can modify
	unsigned int  magic	;	//must equal TOC_U32_MAGIC
	unsigned int  add_sum	;

	unsigned int  serial_num	;	//user can modify
	unsigned int  status		;	//user can modify,such as TOC_MAIN_INFO_STATUS_ENCRYP_NOT_USED

	unsigned int  items_nr;	//total entry number
	unsigned int  valid_len;
	unsigned int  reserved[5];	//reserved for future
	unsigned int  end;
}sbrom_toc1_head_info_t;

typedef struct
{
	unsigned char  name[8];
	unsigned int magic;
	unsigned int check_sum;

	unsigned int serial_num;
	unsigned int status;

	unsigned int items_nr;
	unsigned int length;
	unsigned char  platform[4];

	unsigned int reserved[2];
	unsigned int end;

}toc0_private_head_t;

typedef struct sbrom_toc0_config
{
	unsigned char    	config_vsn[4];
	unsigned int      	dram_para[32];  	// dram鍙傛暟
	int				  	uart_port;      	// UART鎺у埗鍣ㄧ紪鍙?
	normal_gpio_cfg   	uart_ctrl[2];    	// UART鎺у埗鍣℅PIO
	int              	enable_jtag;    	// JTAG浣胯兘
	normal_gpio_cfg   	jtag_gpio[5];    	// JTAG鎺у埗鍣℅PIO
	normal_gpio_cfg  	storage_gpio[50]; 	// 瀛樺偍璁惧 GPIO淇℃伅
                							// 0-23鏀緉and锛?4-31瀛樻斁鍗?锛?2-39鏀惧崱2
                							// 40-49瀛樻斁spi
	char   				storage_data[384];  // 0-159,瀛樺偍nand淇℃伅锛?60-255,瀛樻斁鍗′俊鎭?
	unsigned int        secure_dram_mbytes; //
	unsigned int        drm_start_mbytes;   //
	unsigned int        drm_size_mbytes;    //
	unsigned int      	res[8];   			// 鎬诲叡1024瀛楄妭
}sbrom_toc0_config_t;
#define TOC0_CONFIG_HEAD_OFFSET 0x80
#define  TOC_MAIN_INFO_MAGIC    0x89119800


struct tune_sdly {
/*
	unsigned int tm4_sm0_f3210;
	unsigned int tm4_sm0_f7654;
	unsigned int tm4_sm1_f3210;
	unsigned int tm4_sm1_f7654;
	unsigned int tm4_sm2_f3210;
	unsigned int tm4_sm2_f7654;
	unsigned int tm4_sm3_f3210;
	unsigned int tm4_sm3_f7654;
	unsigned int tm4_sm4_f3210;
	unsigned int tm4_sm4_f7654;
*/
	unsigned int tm4_smx_fx[12];
};

struct boot_mmc_cfg {
	unsigned char boot0_para;
	unsigned char boot_odly_50M;
	unsigned char boot_sdly_50M;
	unsigned char boot_odly_50M_ddr;
	unsigned char boot_sdly_50M_ddr;
	unsigned char boot_hs_f_max;
	unsigned char res[2];
};


#define SDMMC_PRIV_INFO_ADDR_OFFSET (128)
struct boot_sdmmc_private_info_t {
	struct tune_sdly tune_sdly;
	struct boot_mmc_cfg boot_mmc_cfg;

#define CARD_TYPE_SD  0x8000001
#define CARD_TYPE_MMC 0x8000000
#define CARD_TYPE_NULL 0xffffffff
	unsigned int card_type;                     /*0xffffffff: invalid; 0x8000000: mmc card; 0x8000001: sd card*/

#define EXT_PARA0_ID                  (0x55000000)
#define EXT_PARA0_TUNING_SUCCESS_FLAG (1U<<0)
	unsigned int ext_para0;

	/**GPIO 1.8V bias setting***/
#define  EXT_PARA1_1V8_GPIO_BIAS        0x1
	unsigned int ext_para1;
	/* ext_para/2/3 reseved for future */
	unsigned int ext_para2;
	unsigned int ext_para3;
};






